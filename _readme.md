## 1、vue-cli 脚手架初始化项目

**准备**：node + webpack  
**安装**：npm install -g @vue/cli  
**创建一个项目**：vue create app  
**node_modules 文件夹**：项目依赖文件夹  
**public 文件夹**：一般放置一些静态资源。需要注意，放在public 文件夹中的静态资源，webpack 进行打包的时候，会原封不动打包到dist 文件夹中  
**src 文件夹(程序员代码文件夹)**：
- assets 文件夹：一般放置静态资源（一般会放置多个组件共用的静态资源）。需要注意，放置在assets 文件夹里面的静态资源，在webpack 打包的时候，webpack 会把静态资源当作一个模块，打包到js 文件里面。  
- components 文件夹：一般放置的是非路由组件（全局组件）
- App.vue：唯一的根组件，Vue 当中的组件（.vue）
- main.js：程序入口文件，也是整个程序当中最先执行的文件

**babel.config.js**：配置文件  
**package.json 文件**：认为是项目的‘身份证’，记录项目叫做什么、项目当中有哪些依赖、项目怎么运行等  
**package-lock.json**：缓存性文件  
**README.md**：说明性文件

## 2、项目的其他配置

#### 2.1、项目运行起来的时候，让浏览器自动打开
- package.json 文件
```
    "scripts": {
    "serve": "vue-cli-service serve --open",
    "build": "vue-cli-service build",
    "lint": "vue-cli-service lint"
    },
```
#### 2.2、eslint 校验功能关闭
- 在根目录下，创建一个vue.config.js 文件  
```lintOnSave:false```
#### 2.3、src 文件夹简写方法，配置别名@ 提示 【@ 代表src 文件夹，这样将来文件过多，找的时候会方便很多】
```
jsconfig.json 文件
{
    "compilerOptions":{
        "baseUrl": "./",
        "paths": {
            "@/*":[
                "src/*"
            ]
        }
    },
    "exclude": [
        "node_modules",
        "dist"
    ]
}
```

## 3、项目路由分析
**路由组件**  
Home 首页路由组件、Search 路由组件、Login 登录路由、Refister 注册路由  

**非路由组件**  
Header 包含【首页、搜索页、登录|注册页】
Footer 包含【首页、搜索页】

## 4、完成非路由组件Header 与Footer 业务
**开发项目步骤**：  
1. 书写静态界面（HTML + CSS）
2. 拆分组件
3. 获取服务器的数据动态展示
4. 完成相应的动态业务逻辑

**注意**：  
1. 创建组件的时候，组件结构 + 组件的样式 + 图片资源
2. 项目采用的是less 样式，需要通过less、less-loader 进行处理，把less 变为css 样式
3. 如果想让组件识别less 样式，需要在style 标签的身上加上 lang=less

### 4.1、使用组件的步骤（非路由组件）
-创建或者定义
-引入
-注册
-使用


## 5、路由组件的搭建（Home、Search、Login、Refister）
使用 **vue-router**
- components 文件夹：经常放置非路由组件（公用全局组件）
- pages | views 文件夹：经常放置路由组件

### 5.1、配置路由
项目当中配置的路由一般放置在router 文件夹中

### 5.2、总结
路由组件与非路由组件的区别
1. 路由组件一般放置在 pages | views 文件夹中，非路由组件一般放置在components 文件夹中
2. 路由组件一般需要在router 文件夹中进行注册（使用的即为组建的名字），非路由组件在使用的时候，一般都是以标签的形式使用
3. 注册完路由，不管路由组件还是非路由组件，身上都有$route、$router属性
---------------------------------------------------------
- $route：一般获取路由信息【路径、query、params等等】
- $router：一般进行编程式导航进行路由跳转【push | replace】


### 5.3、路由的跳转
路由跳转的两种形式：
1. 声明式导航router-link
2. 编程式导航push | replace  
---------------------------------------------
- 区别：声明式导航能做的编程式导航都能做，但是编程式导航除了可以进行路由跳转，还可以做一些其他的业务逻辑

## 6、Footer 组件显示与隐藏
显示或者隐藏组件：
- v-if | v-show  

Footer组件：  
- 在Home、Search 显示Footer 组件，在登录、注册时隐藏
------------------------------------------
补充

- 可以根据组件身上的$route 获取当前路由的信息，通过路由路径判断Footer 显示与隐藏
- 配置路由的时候，可以给路由添加路由元信息【meta】，路由需要配置对象，它的key 不能乱写

## 7、路由传参

### 7.1、路由跳转的方式
- 声明式导航：:router-link（务必要有to 属性），可以实现路由的跳转  
- 编程式导航：利用的是组件实例的$router.push|replace 方法，可以实现路由的跳转。（可以书写一些自己的业务）  

### 7.2、路由传参，参数的写法
- params 参数：属于路径当中的一部分，需要注意，在配置路由的时候，需要占位
- query 参数：不属于路径当中的一部分，类似于ajax 中的queryString /home?k=v&k=v，不需要占位

### 7.3、编程式路由跳转到当前路由（参数不变），多次执行会抛出NavigationDuplicated 的错误警告
- 路由跳转有两种形式：声明式导航、编程式导航
- 声明式导航没有这类问题的，因为vue-router 底层已经处理好了
#### 7.3.1、为什么编程式导航进行路由跳转的时候，就会有这种警告错误？
- "vue-router": "^3.5.3"：最新的vue-router 引入promise
#### 7.3.2、通过给push 方法传递相应的成功、失败的回调函数，可以捕获到当前错误，可以解决。
```
// （治标不治本！将来在别的组件中 push | replace，编程式导航还是有类似的错误）
this.$router.push({
      name:"search",
      params:{keyword:this.keyword},
      query:{k:this.keyword.toUpperCase()}
    },()=>{
      console.log("跳转成功！")
    },(err)=>{
      console.log(err)
    })
```
#### 7.3.3、重写push | replace 方法




## 8、三级联动组件完成
- 由于三级联动，在Home、Search、Detail 都有使用，所以把三级联动注册为全局组件  
- 好处：只需要注册一次，就可以在项目的任何地方使用

## 9、完成其余静态组件
**HTML + CSS + 图片资源**


## 10、POSTMAN 测试接口
- 如果服务器返回的数据code 字段200，代表服务器返回数据成功
- 整个项目，接口前缀都有/api 字样

## 11、axios 二次封装
XMLHttpRequest、fetch、JQ、axios

### 11.1、为什么需要进行二次封装axios？
请求拦截器、响应拦截器  
- 请求拦截器： 可以在发请求之前处理一些业务
- 响应拦截器： 当服务器数据返回以后，可以处理一些事情
### 11.2、在项目当中经常有API 文件夹---axios

## 12、接口统一管理

- 项目很小：  完全可以在组件的生命周期函数中发请求  
- 项目很大：  axios.get('')

-----------------------------

- 协议、域名、端口号不同请求，称之为跨域

## 13、nprogress进度条的使用
- start：进度条开始
- done：进度条结束

## 14、vuex状态管理库
### 14.1、vuex是什么？
- vuex 是官方提供的一个插件，状态管理库，集中式管理项目中组件共用的数据
### 14.2、vuex 基本使用
### 14.3、vuex 模块化管理

## 15、完成TypeNav 三级联动展示数据业务

## 16、完成一级分类动态添加背景颜色
第一种解决方案：采用样式完成
第二种解决方案：通过JS 完成

## 17、通过JS 控制二三级商品分类的显示与隐藏
```
:style="{display:currentIndex==index?'block':'none'}"
```

## 18、卡顿现象
- 正常：事件触发非常频繁，而且每一次的触发，回调函数都要去执行（如果时间很短，而回调函数内部有计算，那么很可能出现浏览器卡顿）
- 节流：在规定的间隔时间范围内不会重复触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发【可以给浏览器有充裕的时间解析代码】
- 防抖：前面的所有的触发都被取消，最后一次执行在规定的时间内之后才会触发，也就是说如果连续快速的触发，*只会执行一次*

---------------------------------------------

lodash 插件：里面封装了函数的防抖与节流的业务
- lodash 函数库对外暴露_ 函数

## 19、完成三级联动节流

## 20、三级联动组件的路由跳转与传递参数
- 三级联动用户可以点击的：一级分类、二级分类、三级分类
- 当点击的时候：Home 模块跳转到Search 模块，一级会把用户选中的产品（名字、ID）在路由跳转的时候，进行传递

### 20.1、路由跳转
- 最好的解决方法：编程式导航 + 事件委派
- 利用事件委派时会遇到的问题：
  1. 如何确定点击的一定是a 标签；
  2. 如何获取参数【1、2、3级分类的产品的名字、id】
### 20.2、传递参数
```
this.$router.push({name:'search',query:{categoryName:'', id:''}})
```


## 21、开发Search 模块中的TypeNav 商品分类菜单（过渡动画效果）
- 过渡动画：  
前提 --> 组件|元素务必要有 v-if | v-show 指令才可以进行过渡动画

## 22、对商品分类三级列表进行优化
- 在App 根组件当中发请求（根组件mounted执行一次）

## 23、合并参数

## 24、开发Home 首页当中的ListContainer 组件与Floor 组件
### 24.1、mock数据（模拟）：需要用到插件mockjs
使用步骤：  
1. 在项目当中src 文件夹中创建mock 文件夹
2. 准备JSON 数据（mock 文件夹中创建相应的JSON 文件）
3. 把mock 数据需要的数据放置到public 文件夹中
4. 创建mockServe.js 通过mockjs 插件实现模拟数据
5. mockServer.js 文件在入口文件中引入（至少需要执行一次，才能模拟数据）
### 24.2、解决轮播图问题
- watch + nextTick ：  
数据监听，监听已有数据变化
### 24.3、开发Floor 组件
1. getFloorList 需要在Home 路由组件当中触发的，不能在Floor 组件内部触发，因为我们需要v-for 遍历floor 组件
2. v-for 也可以在自定义标签当中使用
3. 组件通信的方式
4. 把首页当中的轮播图拆分为一个全局组件

## 25、Search 模块的开发
1. 请求到search 模块需要的服务器数据，存储于vuex 仓库当中，对一些数据【通过getters】进行简化
2. 对商品列表、平台售卖属性进行动态化
3. 动态开发面包屑中的分类名
4. 动态开发面包屑中的关键字
5. 排序操作

## 26、分页功能实现
- 分页器展示，需要哪些数据？
  1. 需要知道当前是第几个：pageNo 字段代表当前页数
  2. 需要知道每一页需要展示多少数据：用pageSize 字段代表
  3. 需要知道整个分页器一共有多少条数据：用total 字段代表【获取另外一个信息：一共多少页】
  4. 需要知道分页器连续页码的个数：用continues 字段代表    5|7【奇数（对称）】
- 对于分页器而言，很重要的一个地方即为【算出连续页面起始数字和结束数字】
- 分页器的动态展示

## 27、开发详情页面
1. 静态组件
2. 发请求【请求接口】
3. vuex【获取产品详情信息】
4. 动态展示组件

## 开发注册页面
- 账号：17129111111  
- 密码：123